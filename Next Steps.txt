- implement outline LFO (only volume of the original voice for now)
	# ig LFOs will have to go directly into the audio engine (not into the voices) so that there won't be any problems with polyphony and/or modulation later on
	# do reference the LFO in the voice though, but only advance its position while the voice isn't tailing off (-> no problems with polyphony later on)
	# render LFO waveform
	# implement changing the LFO's rate in the settings menu
	- make it possible to modulate other voices
		# change the RegionLfo's modulation function so that it also takes Voice* as an input
		# keep an array of voices in the LFO
			/ by default, only the associated region is in that list
		# overwrite the LFO's update function, so that it applies its update to all voices in the array, in the order they are contained in there
		# in the region's settings menu, show an area with a list of all the different regions (-> currenty equal to their voices, later on it will represent all the voices of the respective region)
		# make all items in that list checkable
		# when loading the menu, look up all the different regions (currently through the voices, later on through the voices' ids) and list them in the LFO's list
			# for a smoother workflow, it would be amazing if the items also took on their respective region's fillColour!
		# when checking/unchecking items from the list, update the LFO's voice array
			# fixed order: smallest region id to largest region id
		# bug: LFOs currently don't modulate their own associated region, only other regions
		# later: when deleting regions, make sure to adjust the LFOs' lists as well!
			/ make the broadcaster a ChangeBroadcaster and add the settings menus as listeners -> notify when the LFOs list changes
	# create unipolar/bipolar LFO modes
		# unipolar: rewrites(!) the LFO's values to 0...1  ->  good for velocity modulation for instance
		# bipolar: rewrites(!) the LFO's values to -1...1  ->  good for pitch modulation for instance
	# implement other parameters to modulate
		!# there will most likely be one major problem with this: the voices' samples are probably not rendered in parallel; it's more likely that each voice renders 1 entire audio block in order
			(/) possible, but rather complicated fix: create an array of LFO modulation buffers in each voice. when an LFO updates another region's parameters, it instead writes an LFO modulation buffer (containing the values that it took on during the current block) and adds that block to the modulation buffer lists of every affected other voice as well as the parameter that the buffer should affect. while rendering, a voice will also parse the current sample of every buffer in its LFO modulation list and thus achieve the modulation sample by sample again. not sure how fast/slow this approach would be, though...
			# other idea: would it be possible for the synth to only render audio blocks one single sample at a time? that would also fix this problem (not sure if it would affect speed though)
				-> alright, apparently this works! will have to see whether this affects performance though. other than that, the only downside is that effects which take blocks to process cannot be used anymore (e.g. most filters, perhaps distortion?), but that should be fine, they probably aren't strictly needed or there might be workarounds
				?- as a workaround for block-based processing: maybe synth.renderNextBlock could only render the raw voice samples (incl. LFO adjustments), and afterwards there could be a method that triggers the block-based processing for all active voices. they only need to remember how their block-based effects' parameters were modulated during this block, though, which might further reduce performance...
		!# one more minor problem: how to handle parameters that are affected by multiple LFOs?
			(-) if every voice were to be handled sample by sample in parallel, it would probably be enough to change the respective setModulated[Parameter] methods to just multiply the modulated value by the passed amount, and to reset the modulated value to the base value at the beginning of each sample
				!# actually, making a variable that collects the multiplications (multiplier = 1.0 * mod1 * mod2 * ...) would be more consistent because parameter modifiers based on addition should be handled in the same manner (sum = 0.0 + mod1 + mod2 + ...) to avoid premature overflows (e.g. sum = 0.0 + 1.0 + 1.0 - 1.0 would return 0.0 when checking for overflows after every addition, but with all mods combined it would return 1.0)!
		# other voices' volume
			# also add a base volume slider to the settings menu (-60dB...+6dB)
		# voices' playback speed (incl. its own)
			# also add a base pitch slider to the settings menu (-60st...+60st -> since one octave doubles/halves the frequency, this corresponds to multiplication by 1/32...32, the formula being mult=2^(semis/12))
		# LFOs' rates (incl. its own)
		/ LFOs' modulation depths (incl. its own)
		# voices' playback positions (incl. its own)
			# would require adding a "slow update" mode to the LFO where it doesn't update during every single sample
			?- also add a base start position slider to the settings menu (0.0 ... 100.0 ?)
		# LFOs' update intervals (not very useful performance-wise, but should sound cool especially with LFOs that modulate pitch!)
		# LFOs' phase (= playback position) (incl. its own?)
			- adjust code that draws the LFO line on the image
	/ implement changing the LFO's modulation depth in the settings menu
		!# make it depend on the shape's size, actually
			/ use the shape's area (bounds) in relation to that of the full image -> being >=2/3 of the image's area should result in full modulation depth
			!# DUDE, it's not even necessary to use its area: just use the *ACTUAL* length of the line, don't normalise it! DONE! positive side effect: that way, the user still has some influence over the form's mod depth!
				- easier to implement for the unipolar wavetable, so calculate that first, and calculate the bipolar wavetable from the unipolar one
				?- still subtract the minimum line length (in relation to the current focus point) since it only adds a fixed offset?
  !				- add a textbox in the region/LFO editor that shows the depth of the LFO with the current focus point
(# outline animations for the LFOs)
!# add a second column of toggle buttons to the LFO voice list that invert the modulation for that region
	-> this would be quite powerful since it enables call-and-response patterns (e.g. while one voice is loud another is quiet / while one voice is high another is low / ...)
	- this isn't as straightforward as it might seem since the modulation function is the same for all voices (whereas inversion would only be applied to some of the voices)!
		- solution: pass an Array<bool> to the lfo that says for which voices inversion should take place. when iterating over the voices, also iterate over that array and apply inversion on the go
			- is there a way to make this possible without if cases? for bipolar LFOs it would be enough to have an Array<int> with either +1 (not inverted) or -1 (inverted) and multiply the LFO value with one of these entries. but what about unipolar LFOs? inverting their values would be (1 - value), which can't really be put into an array
			-> use a second audio buffer containing the inverted waveform? this wouldn't save the if-case, but the following calculation...
		!# (probably) more efficient solution: instead of having just one modulation function, have one modulation function *per voice*
			#> at that point, it would also be easier to modulate different parameters of different voices (essentially making the list into *a mod matrix for every single region*), so that might actually be neat. but, to do that, the checkbox for the modulated parameter would have to also be moved into the listbox instead of being above it, which would require some more work
				# adjust CheckBoxList and CheckBoxListItem
				# Problem: how to handle Polarity? if there are different modulation functions, those are very likely to require different polarities...
					- naive solution: calculate the required polarity on the go -> too slow
					!# compromise: pre-calculate *both* polarities and select the one that's required... -> uses more memory, but saves multiplications
				# rework the modulationFunction/affectedVoices setup in RegionLfo
				# adjust the updateLfoParameter and copy Parameters methods in LfoEditor
	?/ each inversion button is only visible/enabled if the region has been selected
	# actually, an inversion button would be impractical - just make the inverted versions separate parameters
# (D)AHDSR envelope for voices
	# use this as a tester for a cleaner implementation of the state model maybe
	(-) if it's easy to do, also apply the same envelope to the region's LFO, not just the voice(s)
# split the RegionEditor into a different file
	-> possible now that i know how reference forwarding works
	-> create .h and .cpp for SegmentedRegion and for RegionEditor and put empty references to the other at the top of each header class
# split the LfoEditor into a different file
	-> possible now that i know how reference forwarding works
	-> create .h and .cpp for LfoEditor and for RegionEditor and put empty references to the other at the top of each header class
# DAHDSR: skip sustain state if sustain level is 0.0
	# would this cause problems in Voice? -> nope
# bipolar LFOs don't work as they intuitively should yet
	- currently: points closest to the focus point are at 0.0, points furthest away from the focus are either 1.0 or -1.0 (?)
	- how it should be: points closest to the focus point are -1.0, points furthest away are 1.0
	-> the bug was, that the reference point used wasn't actually the focus point *relative to the size of the region*, but actually the raw focus point - i.e. the focus point was assumed to always be in the top-left corner (between (0.0, 0.0) and (1.0, 1.0)...)
- improvements to processing speed
	-> implementing states in a cleaner fashion would probably help the most since it'd cut down on tons of if-cases
	!# implement states for Lfo and/or(?) RegionLfo
	!# get rid of std::function in RegionLfo
		/ neither juce::Array nor std::list nor juce::OwnedArray seem to be able to store function pointers for some weird reason...
			-> do some tests in a separate program
				- try arrays (-> would require lots of annoying dynamic memory re-allocation, so let's hope this isn't the only way to do it...)
				- try struct(/union?) containing the function pointer and make that the element of the list (-> less efficient?)
				?- just define functions in the class instead of using lambdas, and store pointers to those functions instead?
		?-> actually, juce::Array does seem to work, I believe the problem was that the switch case was skipped (wrong variable...) and that led to the error message
	!# get rid of std::function in Voice
		# create a cpp file and simply use a pointer to the RegionLfo instead (will currently require an additional if case, but that will be addressed through the Voice states later)
	!#(?) add a parameter "update time" (or so - just don't use frequency since it needs to be in s, not 1/s) to the Lfo class -> adjustable by the user, 0.0s (real-time updates) explicitly allowed!
		# this does require another if case, but since branch prediction should be easy in this case (simple decrements will occur more often than updates), it should be fine-ish. the true performance increase will occur in combination with the ModulatableParameter class
			(concerning the branch prediction, see https://igoro.com/archive/fast-and-slow-if-statements-branch-prediction-in-modern-processors/ )
		# for a slight performance boost for the 0s case, make that into one or more separate RegionLfo state(s)
		-> NOTE: this won't be audible until the ModulatableParameter class has been implemented (see below)
	!# add a new generic class ModulatableParameter. this class contains the parameter's base value as well as the current modulated value. it also contains a modulator list to which LFOs can add(/remove) themselves
		!# important trick: the class has states which show whether any modulator has updated its value. the new value is only calculated (-> potentially lots of multiplications) when something tries to access the modulated value - instead of updating it every time any modulator updates (which would be much slower). using states (instead of a bool and an if) saves 1 if per sample per modulated value per voice/LFO, so they're crucial
		# adding new modulators: the modulated value creates a new entry (generic value - float or double in this case) in its list of modulators. the modulator (LFO) gets a pointer to that entry (-> quick update) and also saves a reference to the ModulatableParameter class to call a method "hasUpdated" (or so) whenever the modulator updates the value
		# exchange modulation functions for pointers to modulated parameters in RegionLfo, adjust adding/removing modulations (those will now handle defining lfoEvalFuncPt for ModulatableParameter!)
		# when RegionLfo updates, only call signalModulatorUpdated() in each ModulatableParameter instead of all the calculations until now
		# add methods to Voice/RegionLfo for getting pointers to their ModulatableParameter members (required for registering/unregistering modulations in RegionLfo)
		# use ModulatableParameter for Voice parameters
		# use ModulatableParameter for RegionLfo parameters
		!# currently throws a compile error. might be a circular reference problem, but i'm also beginning to suspect some kind of implementation error in ModulatableParameter that intellisense didn't catch (it failed to recognise a non-existing variable last time i checked - might have smth to do with the generics...)
			# plan A: try commenting out every method in ModulatableParameter and then building -> if it builds successfully, the problem lies somewhere in ModulatableParameter!
				- did not fix it
			# plan B: change RegionLfo back so that it doesn't use ModulatableParameter for its own frequency anymore. if it builds... well then at least it's clear where the problem was, maybe it helps. if it doesn't build, reload the last commit for a quicker rollback
				- did not fix it. it doesn't recognise the <double> parameter for the remaining ModulatableParameters then (again still a sign that the cyclic reference doesn't compile...)
			# plan C: apparently, .cpp implementations of a generic class are not necessary or even wrong! -> define ModulatableParameter fully in the header file and check whether that solves it!
				see https://stackoverflow.com/questions/62359169/c-generic-class-why-do-i-need-cpp-file
				- did not fix it
			# plan D: apparently, compiling individual cpp files might give better (or at least less cluttered) error messages -> try it for a few cpp files and see if anything becomes clearer
				-> maybe AudioEngine needs a cpp? -> nope, didn't change anything (probably not a bad thing to leave it in though since compiling individual files is actually pretty neat)
					- actually, it *did* fix a (minor) compilation error in SegmentedRegion.cpp, so that's good
				-> it might be necessary to make the ModulatableParameters in RegionLfo into pointers: https://readforlearn.com/implicit-instantiation-of-undefined-template-when-forward-declaring-template-class/
					(or ModulatableAdditiveParameter<double> has to be defined somewhere before --> an alternative would be to predefine ModulatableAdditiveParameter as being a subclass of ModulatableParameter<double> again)
			/ plan D: write out the cpp files with expanded headers for ModulatableParameter, RegionLfo and Voice. is any one of them missing a forward reference? do they have the requirements to use methods if they need to do so?
				see https://isocpp.org/wiki/faq/misc-technical-issues#forward-decl-members (scroll up a little, anchor doesn't work properly),
				    https://stackoverflow.com/questions/625799/resolve-build-errors-due-to-circular-dependency-amongst-classes
			/ plan E: remove ModulatableParameter use entirely from RegionLfo, Voice, LfoEditor and AudioEngine. If it doesn't build, the error lies somewhere in the code of ModulatableParameter
				(#) maybe this could also be done by only compiling ModulatableParameter? is it possible to do that?
					- apparently that's possible, but it didn't fix it it still tries to compile RegionLfo...
			/ plan F: try running the connections over AudioEngine, i.e. ModulatableParameters exist only in AudioEngine instead of as class members - would that work? And even if it does, would it be efficient enough?
		# if everything works, clean up commented code in RegionLfo and Voice
	!(#) implement states for Voice
 !		!- technically, changing the wavefile of the osc member isn't handled yet
	# switch to function templates or function pointers instead of std::function -> see https://stackoverflow.com/questions/25848690/should-i-use-stdfunction-or-a-function-pointer-in-c
		https://vittorioromeo.info/index/blog/passing_functions_to_functions.html
		https://stackoverflow.com/questions/43948240/sfinae-failing-when-evaluating-a-constexpr-in-a-template-parameter/43949301?noredirect=1#comment74933533_43949301
		https://stackoverflow.com/questions/28746744/passing-capturing-lambda-as-function-pointer/28746827#28746827
		https://stackoverflow.com/questions/9054774/difference-between-stdfunction-and-a-standard-function-pointer/9054802#9054802
		-> function pointers were the way to go in this case
	- make use of certain keywords
		- noexcept: tells the compiler that the method won't throw any exceptions -> more optimisations possible
		- inline / __forceinline: tell the compiler that the method should be inlined
			- methods that are defined in the header of a file are implicitly inline; if they are defined in the cpp, inline can be added at the beginning. forceinline should be used sparingly as too much inlining may actually hurt performance due to larger binaries and paging
		- final (classes)
			- for the state implementations
			- see https://devblogs.microsoft.com/cppblog/the-performance-benefits-of-final-classes/
 !			!- currently missing for AudioEngine (and perhaps others, too)
		/ register keyword?
			- probably overkill, the compiler should do this automatically already...
		- when to use references and when not?
	# correctly using const pointers (vs. pointer consts and const pointer consts) might also be useful for making things cleaner (though not necessarily faster)
		- see https://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const
		- for functions, see also https://stackoverflow.com/questions/751681/meaning-of-const-last-in-a-function-declaration-of-a-class
	# correctly using references could also improve some things (e.g. using references instead of pointers for state implementations and regions' voices, LFOs etc. might be worth thinking about)
		- https://www.tutorialspoint.com/cplusplus/cpp_references.htm
		- note also: https://stackoverflow.com/questions/51705967/advantages-of-pass-by-value-and-stdmove-over-pass-by-reference
		- first comment of the first reply here is also important: https://stackoverflow.com/questions/21215409/does-c-pass-objects-by-value-or-reference
			- for a more direct example: https://stackoverflow.com/questions/9293674/can-we-reassign-the-reference-in-c#9293732
	- declare methods as const if they don't change member variables: https://stackoverflow.com/questions/24500909/passing-class-reference-to-function
  !	- take a look at https://docs.juce.com/master/tutorial_simd_register_optimisation.html
# bug: LFO line doesn't update when LFO doesn't modulate anything
	- a RegionLfoState wasn't set up correctly, that's all
# bug: the LFO line doesn't keep updating while the voice is tailing off (-> just create a bool variable isPlaying in Voice that's checked for that purpose)
# add visual feedback for update rate
	!# idea: adjust update rate of the *line drawing* accordingly! this is a win-win, because it provides feedback and even reduces the CPU usage further!
/ is there a way to make it so that modulation of other regions remains at the current modulation value even when the region modulating it stops playing?
	-> example: currently, if region 1 modulates region 2's volume, the modulation stops after region 1 stops playing (i.e. region 2 plays with its base volume - not the base volume multiplied with the LFO value of region 1 that was last measured). is there a way to apply the LFO's modulation independent from a region playing?
	- idea: maybe advance all LFOs *before* rendering all next synth samples? would that change anything/much?
		!- this would also have the advantage that it wouldn't require a Voice (i.e. an audio file) for a region's LFO to work
		- problem: this would require either the audio engine or the LFOs to keep track of which LFOs are playing, which could require additional if-cases every sample...
			!- solution part 1: when implementing the DAHDSR envelope for the LFOs, it would require them to keep track of whether or not they are playing anyway -> two birds with one stone!
			!- solution part 2: after implementing states for the LFOs and the DAHDSR, there might as well be "Playing" and "Not Playing" states, converting the additional if cases to quick array accesses
			-> definitely doable! now the only remaining question is whether evaluating the LFOs before rendering the voices significantly changes the sound
	- idea 2: maybe don't use a single variable to accumulate modulations. instad, use a list of modulation values with are multiplied/summed during every sample. when an LFO starts modulating a value, its value is inserted into the list and updated after every sample - but only removed when the LFO is deleted or starts modulating a different value. downside: more operations during every sample
	#-> this is now already the case because of the ModulatableParameter class
# implement more LFO-modulatable parameters
# update LFO menu (might not be necessary anymore depending on what has been done at the point that this is next)
# bug: LFO line doesn't update again when the LFO doesn't modulate anything
# bug: the LFO continuously updates after the region has been drawn despite not being played. stops after the region has been played once.
# states for SegmentedRegion
	# when registering a new region in AudioEngine, also generate its RegionLfo and Voice instances! the region will then update these LFO's/voices' wavetable as soon as the user selects it. until then allow to play the region, but only with the LFO active
		# in that case, checkboxes for regions that are missing their wavefile should proooobably stay disabled? (i don't think registering modulators would break anything though)
		# the bigger "problem" would be that the Voice class would need new methods to initialise its osc member, and these updates also need to be handled in the VoiceState members, which might require even more methods...
			- the advantage of this would be that the buffers in the osc member should be exchangable anyway, so...
		#? make sure that when changing the wavefiles of the voices or the LFO, that the new methods for doing so are used!
		# bug: region's background isn't drawn the first time it appears
		# bug: the regions' colours aren't displayed in the region editor anymore
  !		!- bug: sometimes, after completing a region, the SegmentableImage triggers startNewSubpath of the path object somewhere resulting in an exception
			/ it might've been the incorrectly(?) implemented iterator in the tryDeleteLastNode method. it might be fixed now
				- nope, that wasn't it...
			- now that i know how to display the callstack, it should be easier to fix if it occurs again
				- it seems to have smth to do with the LFO line being drawn! maybe it's trying to draw it before the LFO is initialised or smth?
		# bug: the regions remain toggleable in edit mode
	# implement transitionToState method
	# include states' specialised methods in SegmentedRegion
# states for SegmentableImage
	# create SegmentableImageStateIndex
	# create states
	# implement states in SegmentableImage class
# fix memory leaks that occur when closing the program
	!# new evidence: the leak also occurs when switching the SegmentableImageStateIndex back to empty!
		/ i'm beginning to think it might be the SegmentedRegion destructor that doesn't correctly destroy everything yet
		/ idea: LFOs aren't unsubscribed from their modulated parameters when they're deleted, they just clear the lists of the parameters they modulate!
		!/ it's the ModulatableParameter destructor! the "delete state" statements sometimes throw exceptions - why?
			/ idea: maybe the states aren't being initialised? that would mean that in some *constructor*, some parameters aren't initialised (or are using the wrong contructor)!
			-> nope, actually it isn't.
		#> now that i finally know how to display the callstack, it's simple... calling the Lfo destructor in the RegionLfo destructor was the problem. this could've been fixed a lot faster man... but i'm still glad it's finally done and gone.
	/ theory 1: some classes just don't destroy their contents correctly
	/ theory 2: the leaks happen in certain states of SegmentableImage (maybe editable, definitely in playable)
	/ theory 3: some leaks happen because AudioEngine is still rendering blocks while some (playing) parts are being deleted
		-> fix 1: stop audio engine when pressing the close button, then delete all contents
		-> fix 2: implement locks (probably good idea in the long run, but perhaps too much work for this one fix...)
# calculate a region's colour from the pixels behind it
	# use the median of all the colours
	# also increase the region's transparency by 10-20% -> makes it so that the region maintains some of the background's textures instead of being just a solid colour, should look more professional
	?# actually, is it even calculated correctly atm?
		# probably no, see https://en.wikipedia.org/wiki/Median#Multivariate_median
	# still a little slow atm
		# don't iterate over the image's original size - instead, iterate over the images size in the window and map the iterated values to positions in the original image
		- ?
# draw LFO line with a black outline
# draw segmented region with a contrasting outline
# check whether it's possible to resize VSTs
	- huh, apparently it should be possible o.ô -> look into that further!
# bug: samplesUntilUpdate of LFO should be reset to 0 after a voice stops (otherwise, the LFO line will be drawn with a temporal offset...)
# bug: ^- the playback position should do so as well - does it?
# bug: LFO line doesn't recognise modulations of the RegionLfo's update interval
	- idea: get samplesUntilUpdate from the respective LFO every time the LFO line updates and update the rate that way
		!- IMPORTANT: do NOT call the modulated value of the update rate parameter! that would mess with its modulation!
# bug: LFO line doesn't recognise modulations of the RegionLfo's phase
	- reason: getPhase is being called, which outputs the *base value* of the phase, not the modulated value
	- problem: calling the modulated value would mess with the modulation!
	-> solution: since this is a problem that'll only occur once (at least presumably) and not in other instances of ModulatableParameter, it should be fine to just create a new variable that stores the latest modulated phase, and a getter method for that variable 
# add an option to make the pitch shift quantised to either semitones or a normal scale (might be possible to do with the interpolation tables?)
	- this would add SO MUCH since actual, non-chaotic *melodies* could be created with it using a region that pitch mods itself at a slow interval and a second region that alters the first region's update rate or LFO rate
# reset region counter when re-initialising the image
# make it possible to delete regions
	/ to handle all the audio parameters, create a method in the *audio engine*(!) that deletes all voices with the region's id from the LFOs' voice lists, and then all of those voices from the synth
		-> obsolete now
	- ugh, seems like it'll be necessary to create a new SegmentableImageState for this, it can't be handled from the RegionEditor because it'll throw access exceptions from trying to delete a parent while its child is running code...
		!# actually, just add a key binding to delete regions using the delete button during drawing/editing!
# stop playing regions when switching to drawing mode (editing mode should be fine, enables user to open editor windows for some quick adjustments while playing without any interruptions - see next line)
# close region editor windows when switching to drawing mode (playing mode should be fine - in fact, being able to leave the editor windows open while playing would be extremely handy)
# suspend processing of the audio engine while loading in new audio files
# bug: resizing breaks the positions of drawing points
	-> reason: the point values are currently absolute, not relative -> should be a pretty easy fix tbh
# bug: the LFO line isn't drawn before the region is first played
	-> didn't call timerCallback() during resize() (which was a problem because the LFO line coords are recalculated there)
# bug: the LFO line isn't redrawn when the focus point is shifted
	-> same mistake as above
# region counter should reset when the last region is deleted (not just when all regions are deleted at once)
# refresh open region editors when a region is deleted
# increase thickness of inner LFO line
# slightly increase the starting width of the region editor window
# set initial update rate to 10ms
# show yes-no prompt before deleting a region!
#? improve processing speed of redrawing the LFO line
!# bug: when closing the window with a lot of regions on it, some of the parameters end up containing invalid modulators, thus causing an exception
	# pretty sure some LFOs aren't correctly unsubscribed when LFOs/Voices/? are deleted
	# seems like it's probably voice parameters that haven't been unsubscribed after the voice has been deleted(?)
		-> ahh, the LFO didn't unsubscribe other LFOs from its parameters. should hopefully be fixed now.
# give focus point an outline for better visibility
!(#) serialisation
	# saving the SegmentableImage will be a challenge actually, cos the ProcessorEditor may be closed when the data is saved (e.g. when the DAW's file is saved)
	/> new classes SegmentedRegionData, SegmentableImageData -> owned and serialised by *AudioEngine*, pointer provided to and content updated by SegmentedRegion, SegmentableImage
		-> a simple pointer to SegmentableImage is enough (the SegmentedRegions are serialised in there)
	# i think i may have forgotten to code writing all partial memory blocks onto the final memory block, whoops... ><
	# don't forget to add default values to all deserialised attributes! this is to ensure that the program doesn't crash when certain attributes aren't found in the file (for whatever reason, e.g. tampering etc.)
	/ implement the final required update steps in AudioEngine
	# make sure that all cases are respected, especially the one where no data has been loaded yet!
	(#) testing
		# need to switch the state of the main ProcessorEditor depending on what data is loaded
			/> could probably be done in SegmentedImage via a call to its parent (-> the editor) somehow
			#> actually, just make the serialisation of the ProcessorEditor separate from the AudioEngine! that way, AudioEngine doesn't need a reference to SegmentableImage anymore and the state of the editor can be set directly
			#> if an image, regions and at least one audio file have been set, immediately transition to Playing! if an image and regions but no audiofiles were loaded, go to Editing. if an image has been set but no regions, go to Drawing. otherwise, go to Init.
		# image doesn't load in correctly (needs to be redrawn from the ProcessorEditor? idk)
			/> ? (not entirely sure why this is happening tbh, it just loads in partially, looking like the repainting process didn't go through o.ô)
			/ resizing doesn't fix it, so repainting the component isn't the problem
				-> is there an internal method to redraw the image of an image component? maybe smth went wrong there and it's just resizing this partially drawn image because of that
			?/ maybe the old image wasn't deleted correctly?
			# ugh, actually the image wasn't saved correctly: each pixel needs *several* bytes of data, not just one (usually)
		(#) regions' visuals don't load in correctly until they're updated
			/> probably has to do with the image's state - if it's in drawing mode, the regions are disabled. to circumvent this, create a little method that enables, repaints and then disables the regions depending on the state of the image
			-> ugh, this might be kinda annoying to fix actually since the repaint method doesn't repaint immediately...
			# forcing to redraw the buttons' backgrounds can be achieved with triggerDrawableButtonStateChanged!
			#> bandaid fix for now: use juce::Timer::callAfterDelay with repaintAllRegions -> messy and might not work for all users, but at least it works for now...
		# assertion error with synth_numVoices
		?/ seems like the parameters aren't assigned correctly yet (they are displayed in the region editor, but they aren't applied. re-applying them in the editor does not fix this, either)
			-> they seem to be stated correctly in the XML, so it must've smth to do with how they're deserialised
			?- uhhhh, actually they might work correctly after all. it might just be that i got confused because the inverted parameters are still calculated a little weird atm
				-> check with pitch, phase and playback parameters instead to make sure!
		# disable processing while deserialising!
		!# data that doesn't seem to be loaded correctly yet
			# regions' fill colours
			# LFO rate
				-> saved the base value of the parameter, but the parameter is just a pitch shift basically - the required value is in the Lfo class!
			/ amp sustain level(?)
			# update interval (shown correctly, but isn't applied right)
		# stop further deserialisation if no image could be restored
		# image isn't reset when transitioning back to Init state, causing it to get saved
		?# are loaded-in regions set to the correct state?
			-> there's a chance that they sometimes wouldn't have been, but it's fixed, now
		# make a test file for starting in each of the editor's states to check whether they work
			# Init
			# Drawing
			# Editing
			# Playing
/ oh, there's a method setRepaintsOnMouseActivity -> disable that for SegmentedRegion!
	-> doesn't do anything with DrawableButtons actually (because they *need* to be able to interact with the cursor to redraw themselves)
#! check whether the ProcessorEditor keeps its serialised state in the DAW, even after the editor has been closed and then reopened
	-> can be checked using the projucer
		-> good thing i checked, because it really does *not*...
	/ if not, in the Processor, store the pointer to the editor that is (newly) created when it asks for a ProcessorEditor. so when that stored pointer hasn't been initialised, initialise it, otherwise return that stored pointer. that should hopefully fix it.
		-> the juce documentation highly discourages doing that because the editor object may be *deleted* at any given time, which would make the pointer a dangling pointer!
	!# better: if not, keep the instance of SegmentableImage in the *AudioEngine* (as a normal or maybe unique pointer). when an editor is loaded, simply pass a reference to that SegmentableImage and add it as a child, and when the editor closes, remove that child again. also include the serialisation of the image in the AudioEngine. -> done.
		# let AudioEngine know about SegmentableImage
		# update AudioEngine's (de)serialisation methods
		# include its current (target) state when serialising SegmentableImage. set it to its target state when deserialising it
		# register AudioEngine's SegmentableImage when loading PluginEditor (instead of owning its own member of it)
		# after registration, set editor's state according to the current state of the SegmentableImage
		# remove (de)serialisation from the PluginEditor
		# remove PluginEditor from the (de)serialisation in the PluginProcessor
		-> omfg this was such a pain in the ass to fix... but it finally works now! it even keeps playing while the GUI is closed!
?# does swapping audio files work without issues yet?
	-> seems like it, even when the region and/or other regions are playing and modulating each other while the file is swapped
!# implement play path(s)
	# new states in the ProcessorEditor: "Draw Playpaths", "Edit Playpaths", "Run Playpaths"
		#> rename "Drawing" to "Draw Regions", "Editing" to "Edit Regions" and "Playing" to "Play Regions"
		# cover more interactions between states, e.g. not closing region editors when switching to playing paths
	!# simplest implementation:
		# draw a path (like when drawing a region), except maybe that it doesn't necessarily need to be closed(?)
			/ for hitTest: consider using 2 paths - one for the actual lines and one that's slightly smaller and inset according to the outlineThickness. then, return true if the outer path contains the given point, but the inner path doesn't
				-> hmm this has some wonky behaviour actually... and it doesn't seem to work with paths that cross their own outlines, so that's a no-go
			# hitTest idea 2: try using the method that calculates the current distance to a path
				-> works like a charm! yay!
		# in the path's editor, set its walk speed (name subject to change) and maybe the path's colour
			# make the editor wider than tall
		(#) playing the path: clicking the regions doesn't do anything. instead, every playpath (automatically) generates a little point (called a "courier") that wanders alongside its associdated path. when the courier enters a region, it's treated like a click during the "Play Regions" mode
			# doesn't toggle yet
				-> forgot to implement buttonStateChanged(), duh...
			- doesn't display couriers yet
				- courier seems to spawn and gets added as a child, it just isn't displayed. maybe the position is not scaled?
					-> i actually don't know why this happens (it might have smth to do with the courier being partly outside its parent's bounds at the beginning, not sure though) and i can't easily fix it o.ô just drawing the couriers in the playpath now as a bandaid fix...
			# doesn't play regions yet
				# check whether the ranges are deserialised correctly
				-> the regions are simply not registered yet!
					# the problem was that the path's bounds have not been set yet when the ranges were already being recalculated
				# should probably make ranges relative!
				# ranges aren't calculated correctly...
					-> here's the problem: getPointAlongPath returns a point relative to the *path's* bounds. but when doing a hitTest, it checks for collisions relative to the *region's* bounds.
					#> fix: shift origin
			!# regions don't play anymore arghhhh
				?/ possible cause 1: maybe a deserialisation error (check buffer length in seconds)?
				?/ possible cause 2: maybe smth with the play/stop methods?
				?/ possible cause 3: maybe smth with the states of the plugin editor?
					- maybe just make regions playable, might be better anyway
				!#> apparently, the voices are still unprepared o.ô
					- check whether the audio engine is also still unprepared. if so, prepare it upon deserialisation
						-> it does get prepared. with the correct specs, too.
							-> it does get fixed when changing the sample rate / block size manually in the options though o.ô
								#> aha! apparently existing voices didn't get automatically prepared by the synth when the sample rate changed. fixed now!
						?/> maybe the prep fails because the deserialisation takes so long?
					- does it also happen after adding new regions or changing audio files?
						-> yes.
			!# the path isn't quite played accurately yet, seems like the hitbox of the courier is always a centimeter ahead of the drawn point (it is at least consistent though)
				# check if this also happens with newly drawn paths just to make sure
					#> it does *not*!
						/ try adjusting the path's size right after creating it
							-> didn't change anything
						#> setting the SegmentableImage to its image's aspect ratio before deserialising the play paths fixed it
				?/ maybe there are rounding errors when calculating the ranges of the regions, bc the denominator is float instead of double?
					# draw the region edges in the paint method to check this!
						-> they are drawn correctly for new paths, but incorrectly for restored ones.
				#> apparently the courier's location starts off at ~0.9 o.ô
					!#> argh shit... juce::Range objects enforce that their start is smaller than their end, so setting start>end will break things =_=
						# adjust PlayPathCourier::timerCallback
						# adjust PlayPath::addIntersectingRegion
						# adjust PlayPath::evaluateCourierPosition
						-> okay that still didn't fix the offset though, damn... but it had to be fixed anyway, so w/e
			# if the path starts within a region, all such regions must be played rightaway upon playing the playpath
			# regions don't stop playing if the play path is stopped while the courier is in a region
		# (de)serialisation
			# remember to increment the serialisation version number!
			!/ deserialisation doesn't work yet (position isn't restored correctly i don't think? are the relative bounds not used perhaps?)
				#> ah, no, just forgot to implement the resizing, whoops
			# same problem as with the regions: the outline isn't drawn until the path is hovered over
			/ the couriers' speed isn't deserialised correctly, it always goes back to 10.0 even after saving it with a different value
				# also check the editor for possible mistakes!
					#> aha, yeah seems like the editor was the problem, it didn't copy the parameters upon its initialisation
# things that can be made into static consts:
	# initialStateIndex in every class with states
	/ maybe the implementedState variable in the different state classes?
!# add note bindings to regions!
	-> this is a crucial feature because it allows users to let several regions start/stop playing at once!
	# make SegmentedRegion a juce::MidiKeyboardState::Listener add whenever a region is added, pass it as a juce::MidiKeyboardState::Listener to the addRegion method of the AudioEngine where it'll get added as a listener to the keyboardState. then, overwrite the pure virtual methods of the interface.
	# might have to add some way to select specific devices? (shouldn't this be included in the PluginProcessor somewhere?)
	# button toggle state doesn't update when playing via MIDI yet. fixing this will require some sort of message manager though, because it's cross-thread communication.
# bug: cannot draw region points on top of regions
	/> turn off "intercepts mouse clicks"
		-> doesn't work...
	# the only way to make this work was to override mouseDown/mouseUp in SegmentedRegion so that when the region is disabled, it sends the event back to its parent o.ô not too hacky ig. but it's weird that everything else didn't work, not even unregistering the button from the mouse listeners, wth...
# bug: the drawing line of the SegmentableImage is behind its child components
!- check docs.juce.com/master/tutorial_app_plugin_packaging.html




- demo presets
- testing sessions with ant/leon/sam
- survey (incl. privacy policy)
- demo videos (one in German, one in English - both quick rundowns, nothing too in-depth)
	- could show off the presets for a 1min introduction video at the start of the survey and add tutorial videos later when the users received the program
- discord server
- add links to the survey and the discord server to the information box within ImageINe




!# remove the fixed directory paths from the code (loading image, loading audio)
?# maybe make regions playable in play path playing mode
	-> actually, it's possible to do that now since the user can freely switch between "Playing Regions" and "Playing Play Paths" without interruption
	!# do make sure, though, that the regions don't start/stop playing in "Playing Regions" mode depending on whether or not there are couriers in them! (just needs an additional condition in the startPlaying/stopPlaying methods)
!# add save/load program buttons onto the editor (not sure whether all editors inherently provide a safe system - the fact that many VSTs provide load/save buttons makes me think that they don't... also, it would be difficult to provide sample programs otherwise, so... yea, better put buttons on there)
# make it so that a region's outline colour is actually coloured (not just black/white) when it's playing -> easier to differentiate from non-playing regions
	-> use inverted fill colour
!# warning prompt when switching back to init state while an image (and potentially regions and play paths) have been loaded already!
!# display LFO depth in the region editor (somewhat close to where the focus point can be shifted)
!# make the width of the LFO line depend on its depth (1.0 = maximum depth, 0.0 = gone, >0.0 = minimum width)
!# are mp3s supported yet? if not, absolutely do include them! include as many formats as possible in general.
	-> nope, it doesn't
	# add the additional formats
	!# huh, playing the region after loading an mp3 file caused a crash related to a realloc -> maybe this is where locks just have to be used?
		# ohhhh, no, i blieve it's the toggle that breaks it
# LFO phase modulation doesn't seem to work quite right just yet
	-> setup for testing: 1 region modding its own pitch (no quant) at 5 Hz, another region modding region 1's phase at 0.03 Hz -> wobble should alternate between being strong and weak, but it actually doesn' atm (it seems to be correctly displayed for the LFO line though)
	/ idea 1: is this perhaps dependent on the order in which LFOs are advanced? (because that order is fixed!)
	/ idea 2: wrong function for pitch modulation?
	/ idea 3: when an LFO updates its values, does it use the unmodulated phase?
	#> actually, the problem was that phase modulation currently worked differently than what i thought *and* the LFO line used the wrong value to display itself. welp
# make unipolar modulation symmetrical like bipolar modulation (see written note)
	/ maybe only for some parameters (perhaps it only sounds good that way for a select few)
!# updating the focus point position while playing regions can cause an access violation
	-> another case of where locks would be wise...
	#> suspend processing while switching the LFO table...
!# implement a simple means of randomisation
	# add a "randomise" button to the region editor
		-> nice way to quickly randomise everything at once
	# also in the region editor, make it possible to hover over a component and press ctrl+r to randomise the value of that component
		-> nice way to randomise only a selected number of components
		# currently doesn't work - maybe in the if clauses, dynamic casts will have to be used...
		# making the region editor a key listener actually isn't necessary to do this, remove it (for simplicity's sake) and stick to juce::Component's keyPressed method (same but without the second argument)
		!# bug: when randomising the entries in the region parameter list, the values aren't registered in the LFO
	# important: slightly weight the randomness, so that the values produced are actually useful (e.g. don't naively randomise volume - prefer values closer to 0.0dB!)
	# add a randomise button to the path editor
	# also in the path editor, make it possible to randomise a component by pressing ctrl+r while hovering above it
!# bug: changing the modulated parameters in the editor while the region is playing may cause an access violation
	- getting ever closer to having to use thread locks...
	#> fix by suspending processing...
!# bug: changing the region's audio while playing it may cause an access violation
	-> i'm surprised i didn't suspend the audio there yet, i could've sworn i did o.ô
!# messed up the positioning of the LFO depth label again -> adjust!
!# set help texts for all components
	/ there should already be a method setHelpText for all Component members
	# actually, TooltipWindow is what i was looking for. setHelpText, setDescription and setTitle are used for AccessibilityHandler implementations - which is smth that should absolutely be implemented later! but in the context of the bacherlor's thesis, it's most likely overkill
	(#) bug: the sliders don't display their tooltips yet for some reason
		-> ughhh this is a bug with JUCE... the slider's textbox is blocking the cursor from reaching the slider's label. this can be circumvented by adjusting the textbox's size (using setTextBoxStyle), but that will only make the problem less worse, it won't fix it since the textbox will still block the most important part...
		/ hacky solution that might work: when initialising the slider, set its size to smth positive, let's say 20x20, and by using getComponentAt, it's possible to get the actual textbox component (as i've noticed before...). let's hope it's a tooltip client...
		(#) what the...??? so apparently, it's enough to call setTextBoxStyle in general, even when setting the size that that of the entire slider?? dafuq? (it's obviously fixable now though)
	# bug: tooltips don't show for custom components (DAHDSR editor, LFO editor)
		/> gotta add the tooltip window to them again?
		-> only affects the DAHDSR editor's sliders (see previous bug) and the checkboxlist
			#> oh, there's a method getTooltipForRow of the ListBoxModel class
# add a warning prompt for when the user tries to switch away from drawing mode while there are points on the image
# allow the user to choose a play path colour
	# actually make them be able to choose both a normal colour and a down colour! that way, it's easier to retain a good contrast than by code, probably. by default, just set the down colour to the normal colour darkened by 0.2 or so.
# add MIDI note bindings to play paths?
!# add some kind of information button that displays key mappings for each mode (e.g. using backspace to delete points while in drawing mode)
	# can be easily implemented using NativeMessageBox (or whatever it was called)!
	# should also include my name, a link to the survey, to the demo videos (on YT, presumably) and to the ImageINe discord server
!# add more/better key bindings
!# HOOOOLD ON A GOD DAMNED SEC. why didn't i think of quantising the update interval (just like i did with the pitch)??? it shouldn't be too hard to quantise it to powers of 2, for example, which would be PERFECT for rhythms!
	-> e.g. 1/4 quantisation: urate_quant = floor((urate_modfull / urate_base) / 0.25) / 4 * urate = floor((urate_modfull / urate_base) * 4) * 0.25 * urate_base
!# update quantisation: 1/1 = continuous, actually... remove it immediately - right now, it won't do much damage, luckily.
!# scale the components in the editors percentually with the window's size, so that resizing them actually makes sense from a space conservation standpoint...
!# bug: apparently, sometimes, too many LFOs get serialised even when not all of them are needed
	/ probably a bug with deleting regions?
	!-> it happens when the highest region ID is larger than the number of regions in the save file, so it's actually very important to fix this!
-? don't display the "preset has been loaded" window - even if the loading fails, it would show (because the result can't be checked with the given method...)
!# make sure that users can't break anything by playing with options in the region editor while no audio file has been set yet!
	-> seems good
?/ show a warning prompt when trying to open a preset while not in the init state
	-> actually, even the dumbest user should be smart enough not to know that imho...
!(#) bug: sometimes, the key bindings for switching the editor mode don't work
	- idea 1: might be the laptop being slow
	!- idea 2: it might also be because the editor windows or some component grabs the keyboard focus?
		-> try grabbing keyboard focus after transitioning modes?
	/ idea 3: maybe one of the keyPressed handlers (presumably in the playable states) in SegmentableImage returns true even though a key wasn't handled?
	-> added a DBG output for PluginEditor::keyPressed now. if it doesn't register the key presses, it might be idea 2, otherwise idea 1.
		-> it doesn't receive the key pressed when it happens!
	-> ohhh i think it's when one clicks the plugin's window instead of its area... yikes...
		(#)> so i managed to fix it partly by telling editor windows to give away their keyboard focus when they close. but since one cannot access the window in which the plugin editor lives, one cannot tell it not to grab the keyboard focus, damn...
!# gotta reset the state of the AudioEngine before deserialising it! -> if there's an editor, need to tell it that SegmentableImage has been deleted and needs to be replaced!
!/(?) bug: read access violation when removing a modulator (in ModulatableParameter)
	/> the usual: suspend processing...
	#?> actually, this was probably because the new parameters weren't unsubbing their modulators in the class's destructor!
?- i'm getting a feeling that the current play position modulation causes some audio fragments at certain values atm. it might be that the laptop is just too slow though, not sure. better check tho!
	-> a good way to test this would be to find a program state that sounds laggy, switch to a release version and check whether it sounds laggy there, too
# bug: updating the toggle parameter in the region editor while in playing mode doesn't affect the region when actually playing it. to update it, one must go back into editing mode and back to playing mode o.ô
# bug: play paths are already interactable while in drawing mode -> handle them in the same way as regions in region drawing mode instead!
	-> arghhhh it's because of some involuntary setback again... easy fix though, thankfully
?- maybe make the phase modulation parameters into a new class that calculates modulo 1.0 at the end - in that case, one fmod calculation could be replaced with one if case, which should arguably be faster
!# display play path length (normed) in the play path editor!
	-> this is very useful to coordiante the different play paths
	!# not scaling-independent yet...
!# add a panic button (stops all regions (does NOT allow for tailoff!) and play paths)
	# should be red and say PANIC in capital letters
	# next to the mode selection would be a good place i think. there's still plenty of space left there
	# also needs to affect AudioEngine: turn off all notes
	!# doesn't work for play paths yet...
(#) implement more scales (esp. pentatonic scales and various modes)
	# half up: 0 in first half of the octave, 1 in the second half
	# half down: -1 in first half(?), 0 in second half	(alternatively 0 and 11)
	# reversed major/minor/semis: like the normal version, but instead of going from 0 to 12, they go from 12 to 0 -> saw-like steps through the different octaves
	# japanese scales
	# check wikipedia for inspiration
	- later: add modes maybe (phrygian etc., perhaps including popular alterations like phrygian dominant)
- implement more parameters
	-> to add any new parameter:
		- add new LfoModulatableParameter value
		- implement the new parameter for the affected class
			- add the parameter members
			- add initialisers
			- add handling of the parameters
			- unsubscribe all modulators from the parameter in the destructor of the class
			- add serialisation/deserialisation for the parameter's base values, if needed
				-> consider incrementing the current serialisation version!
		- add getter method for that parameter in the AudioEngine
		- add switch case for adding a modulation to the new parameter in RegionLfo
		- add switch case to deserialiseLFOs_mods method in AudioEngine
		- add editing options for the parameter in the respective editor
			- edit base value, if needed
				- add public getter/setter methods for the parameter's base value
				- add UI elements (incl. tooltips)
				- adjust resized method
				- adjust copyParameters method
				- add randomisation methods and adjust the keyPressed and randomiseAllParameters methods to include the new randomisation
			- add entry in combobox for modulation selection
			- add tooltip for item selection with the parameter selected for modulation
			- adjust updateLfoParameter in LfoEditor to include the new parameter
		- consider incrementing the current program version
	# current LFO phase (rename current implementation "LFO phase multiplier")
		^# actually, call it "LFO interval" and "playback interval". that way, they're more intuitive.
		- is there a way to calculate this modded value efficiently without if cases?
		- draw the current minimum and maximum phase onto the region similar to the current phase -> better visual feedback
	^# gotta differentiate between current phase and starting phase!
		# starting phase: value within [0,1) (actually [0,360), but normalising it makes it more understandable). the end phase is determined by the phase multiplier: currentPhase starts at startingPhase and ends at ((startingPhase + 1.0) * phaseMult) mod 1.0, so implementing startingPhase would be rather simple using an additive parameter with a base value that's settable in the region editor
		# current phase: value between startingPhase and endPhase (where endPhase may also be smaller than starting phase). there are 2 ways to do it, but both come with complications:
			1) the unmodulated current phase of the LFO is the base value and the parameter is additive. in this case, the base value would change during every single sample, causing a potentially significant overhead in calculations. furthermore, the result would be underwhelming since it's not the actual current phase that would get set but only the current phase *in relation* to some other phases.
			2) the parameter actually changes the current "unmodulated" phase to a different value (within [0,1) representing the position within the current startingPhase and endPhase). the advantage of this would be that it works as one would expect intuitively, but the downside is that it cannot be done like this with the current parameter classes. the new class would have to use a method that passes a pointer to the current phase value, and if (handling if-cases using states!) the parameter is up to date, it simply wouldn't do anything to the value, but if it's out of date, it would additively calculate its new value and set the current phase to it. so making it a subclass of the additive parameter class would make sense i guess.
			#> use approach 2)!
	^# do the same for the playback position stuff (see below)
	# current playback position (rename current implementation "current playback position multiplier")
		- is there a way to calculate this modded value efficiently without if cases?
	!- panning
	!- stereo width
		- separate the mono signal from the side signals -> multiply the side signals by the current stereo width value (0...1) -> merge the mono and side signals back together
	?- LFO value multiplication (ringmod)
	?- LFO value addition
	?- "sync"
		-> trick: using ModulatableMultiplicativeParameter<int>, one can create a big logical AND, and using ModulatableAdditiveParameter<int>, one can create a big logical OR. now, if one takes the unipolar LFO values and rounds them to 0 or 1, one can create a type of sync: if all (or any) modulations result in 1 (-> true), reset the LFO/playback phase. like with current phase modulation, this would use the modulateValueIfUpdated method.
			-> inversion would simply set each modulator's value to 1-value, effectively negating the boolean value
	!- interpret the LFO wavetable as a waveshaping table, where the starting value is at the LFO's current phase
		- this would (most likely) result in rather distorted sounds that change over time
		- depth: dry/wet mix
!# some update rate quantisation settings cause the update rate to become 0 o.ô
	-> ahh, it's probably cos i used std::floor, causing the multiplier to easily become 0. changed it to ceil now.
!# regions (and maybe play paths) don't act like toggleables when playing play paths (or regions in the other case) even if they are set to toggleable
# try resetting the voice's DAHDSR when its current playback position gets modulated. if it sounds good, keep it.
	-> sounds better imo
	!#> add a note in the respective modulation tooltip
!# regions no longer turn off when clicking them o.ô
# make it so that un-playing via MIDI and un-playing via clicking overwrite each other, seems more intuitive.
	# doesn't keep playing while MIDI is pressed atm
		-> only happens in playing regions mode
	# play plath MIDI needs two interactions to start/stop playing when it's used after clicks have come in
# make the LFO depth calculation more lenient maybe
	# perhaps don't subtract the minimum?
	/ perhaps compare the max length to the length of the actual diagonal instead of the squared diagonal?
		-> actually did so already
# order scales more alphabetically
# decrease minimum LFO frequency to 0.001Hz
!(#) analyse CPU performance to check whether any remaining points in this section actually need to be addressed.
	-> https://learn.microsoft.com/en-us/visualstudio/profiling/beginners-guide-to-performance-profiling?view=vs-2022
	-> seems like it's mainly the UI that's eating tons of ressources. optimising little things about the rendering of voices wouldn't do much i fear...
		!-> put that into the thesis maybe
!/ display version number in the window's title bar
	-> not possible from within the program, argh...
# delete all empty cpp and header files

# bug: the keyboard shortcuts for (un)playing and toggling don't really act like clicks since they don't overwrite MIDI
!# serious bug: the program sometimes crashes when playing regions
	-> apparently, it's caused by negative buffer positions o.ô
		-> effectiveBufferPos is NaN
			- is was possible for the interval parameter to become 0.0, causing a division by zero when calculating the buffer pos (or phase for the LFO)
				-> make a new class for modulatable multiplicative parameters that have a lower cap, so that jmax can be left out in the final calculation and ifs are reduced
!# serious bug: sometimes regions won't stop playing
	?/ can't really reproduce it... might've had smth to do with the keyboard shortcuts not properly acting like clicks(?)
	-> seems to happen regularly in the Meditative preset
		!#> apparently, removing the current playback position modulation breaks things
			/ maybe the new method doesn't transition the modulatable parameter back to being up-to-date?
			!#> actually, it's because one of the regions in that preset has a long envelope and modulates its own playback position! since the envelope gets retriggered every time the current playback position is updated, the voice never finishes releasing!
				# in the same preset, i also noticed that the delay time shouldn't be taken into account for the DAHDSR reset...
# don't reset a region's audio buffer position during noteOn. instead, only reset it when it's forced off, when its release time ends or when the buffer has been changed. that way, replaying a region while its release is still going won't reset it - a much more intuitive behaviour.
?# it seems like some modulations might still not be loaded in correctly (opening the editor fixes it). it noticable especially for current playback pos modulation because there, the envelope should restart.
	# hmm it seems like all modulations do get re-added when opening an editor, but that in itself might actually be good(?)
	?-> code of adding modulations seems clean (AudioEngine, RegionLfo, ModulatableParameter)...
	-> they do all seem to get added during deserialisation -> don't re-add them when opening the editor
	?!/ it seems to happen especially with current playback position(?)
	?!- apparently the modulations are added, but they don't use the correct update interval until they are re-added o.ô
	?- it also seems like a region's update rate doesn't change if a different region, that modulated it, removes that modulation
		-> could be a bug with the update rate
		- hmm... actually, the LFO line itself already updates at the correct rate, that's weird o.ô
			/ it's even weirder: when setting the update rate to a ridiculously high value, the region keeps getting modulated! what??
	#> uhhhh so I took the code that adds modulations from the LfoEditor and inserted it into the AudioEngine to use it during deserialisation and now it works. i'm honestly not sure what it does differently but hell, i'm not going to question it at 9 pm...
# bug: LFO lines don't update if their LFO doesn't modulate any parameters
	!#> latestModulatedPhase is only updated within updateCurrentValues
# urgh, why the hell did i remove continuous update rate quantisation? 1/1 would normally mean that the update rate cannot be modulated...

!# setting current playback position during attack time will change the initial volume
	-> whoops, changed a wrong variable there ><
# inverted volume modulation sounds a lot more quiet than normal volume modulation -> check whether the formula is correct!
	-> found the mistake!
!# reset samplesUntilUpdate when voice stops
	# actually, do so when it *starts*. that way, it's more consistent with update rate modulation and it might even work after polyphony is introduced!
!(/) formula for inversion still seems to be wrong wth?? (check volume especially)
	# hmm, the formula is definitely right tho...
	# checking again, it does feel correct o.ô maybe the build that i saw it on was wrong
	?-> ahh, it's probably because volume modulation is linear whereas volume in general is logarithmic, i.e. if the base values of two sounds are vastly different, their volume modulations will sound different...
# automatically set the MIDI response of regions upon creation: any channel, C4 + [region number] as the note.
# when using WASD/arrow keys to switch states, the order is wrong (not the same as in the combobox)
# randomising the entire LfoEditor using ctrl+r doesn't work yet
	-> it's because it only passes the keypress - if the return value of that is false, randomise the entire component

- when new voices are added, they don't automatically receive the region's modulations... that's smth that should be fixed before polyphony is implemented




!- OH. MY. GOD. why didn't i see this earlier? THERE'S THREADS WITH A PROGRESS WINDOW!
	-> https://docs.juce.com/master/classThreadWithProgressWindow.html
- add a button next to the LFO phase editor to switch its units to ms instead of Hz
	-> this would be extremely useful because it makes it possible to sync the LFO's frequency to its update rate without rounding errors
!- add a subtle watermark to the image
	- maybe one little textbox in a corner + a mostly transparent font across the image?
- ensure that outlined paths actually constitute a 2D plane
	- calculate determinant -> if it's close to 0, it's not 2D
- use the SynthesiserSound class to store the sampler data for voices (instead of storing the data in each voice separately). that way, the audio data only has to be stored once instead of [polyphony] times, and adding new voices only requires a reference to a region's sound instead of a full update.
	-> can use the SamplerOscillator class to do this, it's already derived from SynthesiserSound!
	- actually, also derive it from SamplerSound instead of just SynthesiserSound - that class should fit the purpose of the implementation a lot better obviously
- add a combobox to the region editor to switch between "simple options" and "advanced options" to make things easier to get into
	- ADSR instead of DAHDSR, no setting for the peak volume
	- no update rate slider
	- no pitch quantisation settings
	- no initial LFO phase / phase multiplier, playback pos / pos multiplier settings (in case i'm adding these options at some point)
- code QoL: clean up obsolete commented-out code sections in the code
- code QoL: add descriptions to all major methods
- code QoL: organise the order of the methods in all the classes. also use pragma regions whenever it's helpful
?/ minor bug: window is still resizable even when in editing/playing mode
	- dunno why this happens... the handle doesn't show anymore, so the command seems to go through, so why does it still allow dragging?
	- weirdly enough, this doesn't happen for the play path editing/playing mode o.ô
	#> in fact, it doesn't happen anymore in general o.ô well, that's odd, but alright. 
- minor bug: play paths are displayed with their ON colour after they've been newly created. it updates as soon as the user interacts with the path though.
?- it might be necessary to optimise the serialisation process at some point (ugh...)
	-> context: some DAWs call getStateInformation A LOT (e.g. when only 1 parameter handle is turned), i.e. saving all image/audio files in that method but be hell
		-> BUT since ImageINe doesn't use any parameters currently, it might be safe




!- display version number in the buttom left corner of the screen and in the window's title bar
- fix some bugs/things that would cause problems with unknowing users
	/ since regions currently only keep their voice's index, errors would occur if regions that were created earlier than that region were deleted
		-> fix: when implementing polyphony, voices will have a certain variable that refers to their region. simply delete only voices with the corresponding variable value -> two birds with one stone
	/ voices would currently keep playing while toggled on and switching to editing -> region could be deleted while playing -> errors in audio buffer!
		-> fix: tell the synth to stop all notes without tailoff when switching from playing to any other state
		# actually, it's kiiiinda nice to be able to edit an LFO's parameters while the sound is still playing... maybe there's a way to only force a stop when selecting a new audio file?
	# when setting a region to togglable, they also toggle in editing mode
		-> fix: only update their toggleable state when switching to playing
		- see above bug; maybe make an exception for editing mode (but switch all regions to off when switching back to playing mode maybe)
	# make it so that regions can only be created when at least 3 points have been added to the screen (might already be in the code)
	(!)- bonus: make it so that regions can only be created if the points aren't on a line
	- safer audio file loading (see juce tutorial)
#? implement states the cleaner way: using the actual state model (i.e. using interfaces)
	/ for PluginEditor
	# for SegmentableImage
	# for SegmentedRegion
	# for Lfo (updating the parameter while wavetable isn't set currently takes up ressources every sample)
	# for Voice/Sound probably (again, ressources are taken up while the audio data hasn't been loaded yet)
- additional play path features:
	- custom path colour
	!- make the region playing timing more accurate
		- instead of just calculating during which checks the courier is within a region and when it isn't, check in advance whether it's going to enter/exit regions during its next tick and if so, calculate the time until that entering/exiting would happen from the courier's delta distance. then, call juce::Timer::callAfterDelay() with the corresponding time and event.
		-> allows to play regions for less time than the update rate (so ultra short blips are possible) and makes the entering/exiting timing more accurate (it will feel quantised to the regions' borders instead of being quantised to the courier's update rate)
	!- allow for branching, i.e. points where the path splits in two
		!- option 1: when the runner gets there, it splits in two as well
		- option 2: when the runner gets there, it randomly(?) picks one of the two paths
	!- allow for runner lifetime
		- twist: remaining lifetime of a runner determines its remaining size
			-> the longer a runner travels, the smaller it becomes
			- option A: the decay time should be path-/runner-independent, make it a constant
				-> starting size: depends on path length + runner speed! the longer the path and the slower the runner, the bigger is its starting size
				-> feels very individual, but could grow out of control or feel disappointing(?)
			- option B: the starting size of a runner should be constant for a path
				-> decay time: depends on path length + runner speed
				-> probably more controllable, but less impressive(?)
			- make it so that clicking a path/runner also increases its lifetime
		- when beginning to play, a runner appears on every path with its starting life.
		?- in addition to the lifetime: maybe a maximum number of total interactions (messages to be delivered) regardless of lifetime?
	- things that a playpath could do when it interacts with a region:
		(-) randomise some of its parameters (maybe even ones like the position of the focus point etc.)
		(-) set its focus point to its current position
			-> problems: very costly + doesn't work when more than one runner is inside a region
		-> it would be best if it was something that
			1. depends on the runner's position inside a region
			2. works for cases where there is more than one runner inside a region
			3. depends on the coverage of the region by the runner(s)
		?-> maybe just overwrite the region's volume? (more coverage = louder)
		- maybe gradually increase a runner's remaining lifetime
	- things that a playpath could do when it interacts with another playpath:
		(-) set that playpath's runner to the location where the interaction was
		- start playing the other path, starting from the point of the interaction
		- reverse that path's direction
		(-) randomise some of the other path's parameters
		!- increase the other path's lifetime
			-> that way, the paths can extend their own playtime
			- do not increase the lifetime beyond the runner's starting lifetime, otherwise a feedback loop might occur
	- things that runners could do when they collide with other runners
		- subtract each other's remaining lifetime so that only one of the two remains
	- complete only a given number of laps along the path before stopping
!- allow for 2-voice-polyphony
	- add *2* voices *and 1 sound* per region
	- add a variable to the voice and oscillator class that represents the region, and tell it that it can only play sounds if its variable corresponds to that of the oscillator
		- add a counter variable (uint should suffice) to the audio engine. this variable is incremented every time a new region is created. the regions take on the current value of the counter when they are created. -> unique ID
		- display the region's ID in the title of the region's settings menu!
		- all juce::Component objects should have a methods getComponentID/setComponentID -> use those
	- instead of using Voice.startNote, use synth.noteOn to play sounds
		- maybe overwrite this somehow? how will the synth know which sound to play?
			!- maybe make it so the sound can only play one specific MIDI note, and the region plays that specific note
				- this has the added benefit that implementing MIDI support for the instrument will be easier - just make that MIDI note adjustable in the region editor!
	?- when the current playback position gets updated through modulation, make it release the current voice and start another(?) to make the transition much smoother
- option to set an LFO's rate to that of its associated region's sound
- button to reset an LFO's phase
- add an option to reset a region's LFO phase and/or playback position when its voice stops playing
?- add an option to only register an LFO's modulations while its region is playing. i.e. if a region starts playing, its LFO registers itself to all parameters that it's supposed to modulate, and when it stops playing, it unsubscribes from all the parameters again
	- one thing that could be done with this: a region A with phase mult 0 modulating another region B's pitch -> one can play A to temporarily change the pitch of B, e.g. to achieve a different harmony
- make it necessary to provide a product key
	- see https://docs.juce.com/master/tutorial_online_unlock_status.html
	  ^- apparently, there's a way to make this work offline, too!




possible features to add later:
!- improve region drawing algorithm using image information
	- differentiate between left and right clicks: left clicks use the automated outline finder, right clicks simply draw straight lines like they do now -> more flexible
!- GPU-accelerated UI drawing (change the editor window to an openGL-animated window)
!- sync tempo to DAW's BPM
!- add an option to quantise the start/stop timings of voices to certain note values corresponding to the DAW's BPM
	- this would be an amazing quality of life change, but idk how easy this would be... i know that the DAW's BPM should be contained in some MIDI signals, but idk where or when or how to evaluate them to achieve synchronisation
	- did smth similar in Langton's Ant Sequencer, and it's not quiiiite so easy to do, sadly
!- make it possible to modulate more than 1 value of every region
- in the same update as -^ make it possible to modulate parameters using the DAHDSR envelope
	- consider adding one or two more envelopes
	- implementation: add a new class ParameterModulator, move all the modulation-related stuff from RegionLfo to there and make both RegionLfo and DahdsrEnvelope into ParameterModulators
	- consider adding an update rate to DAHDSR envelopes, too. while the sections that have a constant value are super lightweight, the ones that evolve would currently update with every sample!
- in the same update as -^ make it possible to modulate DAHDSR envelope parameters
- take sidechain input as audio input for regions (writes audio continuously to a small buffer to enable pitch modulation etc.)
- add further (optional) effects like filters, distortion or reverb
	-> this won't be all too straightforward sadly... many of these effects require processing that isn't sample-by-sample, i.e. this kind of processing would either have to be separate from all other processing, or the entire way processing currently works would have to be rewritten
	- make it possible to modulate these effects' parameters
	- maybe add granular-shift-based pitch shift
(- add parameters for the DAW to modulate)
	- WARNING: since some DAWs call getStateInformation really, really often when parameters are changed, this might require a large-scale rework of the serialisation process...
- implement thread-safety-related concepts
- add playback modes for the voices and LFOs: Normal (Forward), Oneshot (voices only?), Forward-Backward, Backward-Forward, Backward
	-> this could be especially interesting in combination with the playback position/length parameters!
- more interesting play paths
	- maybe some more objects (other than regions) that the paths can interact with in some way?
- add visual feedback for playback position/length
	- probably better to add this only in combination with the GPU-accelerated UI drawing, otherwise it might be too costly
	- idea 1: use a second (but smaller) pointer line -> regions look a bit like clocks
	!- idea 2: clockwise wipe on the background of the region, with unplayable areas being greyed out
!- button to open/save settings in a regions/play path editor
- smooth transitions for when a region's playback position changes
- implement AccessibilityHandler to set help texts, descriptions and titles for all objects that can be read with screenreaders
?- make it possible to modulate a DAW's parameters (perhaps ImageINe's own) using the region LFOs
- modulate a region's LFO depth using a(/the voices') DAHDSR modulator
	-> would be pretty simple to implement (excluding UI): add a DAHDSR to RegionLfo and start/reset it in Voice whenever the Voice's DAHDSR is also started/reset (should be fine even with polyphony imo)
	-> idea for a quicker implementation: set the LFO's DAHDSR parameters to the same values as the voices' DAHDSR, except that the levels should be capped at 0dB (since that translates to 1.0!)
- add an option to only update a voice's current pitch when it starts playing
	-> neat to implement regions that contain a single-pitch waveform and are called often
	-> would be especially cool in combination with the polyphony and one-shot updates!
	- this shouldn't be too hard to implement: add a class for the state (which will handle the method which sets the voice's current phase and also has a method that will be called during the voice's noteOn method) and add two implementations of it. the first uses the normal method for aquiring pitch (looking for updates during every call), the second has a member variable storing the modulated pitch that was detected when the noteOn method was called and only ever returns that value for the pitch method.
- make it possible to add ranges of MIDI notes that a region responds to (instead of just one note), affecting a region's pitch
	- setting the: pitch define base note?
	- when using pitch quantisation, make sure *not* to shift the entire scale when playing a note! instead, shift the position of the base note according to the note within the range, so that it just play a different note *within the same* scale.
